/*
 THIS FILE IS AUTOGENERATED WITH PILOT-CONFIG v2.5.4. DO NOT EDIT
*/

use pilot_sys::var::{PilotBindings, VariableInfo, MemVar, Var, TypeName};
use pilot_sys::async_util::State;

use pilot_macro::{root_var};
use crate::pilot::variables::PlcVars;

#[repr(C)]
   pub struct Aio20_1 { 
     pub in3: u16,  // 0
     pub in1: u16,  // 1
     pub in2: u16,  // 2
     pub in0: u16,  // 3
     r1: u16,        // 4
     pub in5: u16,  // 5
     pub in4: u16,  // 6
     r2: u16,        // 7
     pub in7: u16,  // 8
     pub in6: u16,  // 9
     pub in9: u16,  // 10
     pub in8: u16,  // 11
     r3: u16,        // 12
     pub in11: u16, // 13  
     pub in10: u16, // 14
     pub in13: u16, // 15
     pub in12: u16, // 16
     r4: u16,        // 17
     pub in14: u16, // 18 
     pub in15: u16, // 19

   }
   #[repr(C)]
pub struct Motor { 
  pub flags: u8,
  pub position: u32,
}


#[repr(C)]
pub struct plc_dev_t {
  pub m1: u16,
  pub m2: Aio20_1,
  pub m3: [Motor; 6],
  pub m4: u16,
}


pub trait PilotAccess {
    const FIELD_NUM: u16;
    const VARIABLES: &'static [VariableInfo];

    fn plc_varnumber_to_variable(&self, number: u16) -> Option<&dyn MemVar>;
}

impl<T: Default + TypeName> PilotAccess for Var<T>
where
    Var<T>: MemVar,
{
    const FIELD_NUM: u16 = 1;
    const VARIABLES: &'static [VariableInfo] = &[VariableInfo {
        name: "value",
        ty: T::TYPE_NAME,
        fields: &[],
        field_number_offset: 0,
    }];

    fn plc_varnumber_to_variable(&self, number: u16) -> Option<&dyn MemVar> {
        match number {
            0 => Some(self),
            _ => None,
        }
    }
}